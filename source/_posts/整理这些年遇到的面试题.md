---
title: 整理这些年遇到的面试题
date: 2020-08-04 10:09:40
tags: java面试题 java
---

# 前言
总是觉得自己记性特别不好，好多技术相关的东西都是记完了就忘，记录一下自己整理的一些高频面试题。方便随时翻阅加深记忆。

# java基础

## java线程的生命周期 
线程一共有 6 种状态

- NEW （初始状态，线程被构建，但是还没有调用 start 方法）
- RUNNABLE （运行状态，JAVA 线程把操作系统中的就绪 和运行两种状态统一称为“运行中”）
- BLOCKED
-- 阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况：
--- 等待阻塞:运行的线程执行 wait 方法，jvm 会把当前线程放入到等待队列
--- 同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm会把当前的线程放入到锁池中
--- 其他阻塞:运行的线程执行 Thread.sleep 或者 t.join 方法，或者发出了 I/O 请求时，JVM 会把当前线程设置为阻塞状态，当 sleep 结束、join 线程终止、io 处理完毕则线程恢复
- WAITING 等待
- TIME_WAITING （超时等待状态，超时以后自动返回）
- TERMINATED （终止状态，表示当前线程执行完毕）

如何关闭一个线程
Thread.interrupted

## 线程池的实现原理



## 序列化的底层是怎么实现的。

假定一个User类，它的对象需要序列化，可以有如下三种方法：

（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化

ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。
ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。

（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。

ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。
ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。

（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。

ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。
ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。


注意事项：
- 序列化时，只对对象的状态进行保存，而不管对象的方法；
- 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
- 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
- 声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。
- 并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如：
    1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。
2. 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。

参考自：https://blog.csdn.net/xlgen157387/article/details/79840134


## synchronized的底层是怎么实现的。
synchronized简单的说就是java锁，通过代码层面的加锁，让代码在并发情况下按照我们定义的执行顺序来执行。
synchronized 有三种方式来加锁，分别是
1. 修饰实例方法，作用于当前实例加锁，进入同步代码前
要获得当前实例的锁
2. 静态方法，作用于当前类对象加锁，进入同步代码前要
获得当前类对象的锁
3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同
步代码库前要获得给定对象的锁。

synchronized在jdk1.6之后做过优化，引入了偏向锁，轻量级锁的概念，假设以下三种场景
- 情况一:只有 Thread#1 会进入临界区; 
- 情况二:Thread#1 和 Thread#2 交替进入临界区,竞争不激 烈;
- 情况三:Thread#1/Thread#2/Thread3... 同时进入临界区， 竞争激烈

偏向锁</br>
此时当 Thread#1 进入临界区时，JVM 会将 lockObject 的 对象头 Mark Word 的锁标志位设为“01”，同时会用 CAS 操作把 Thread#1 的线程 ID 记录到 Mark Word 中，此时进 入偏向模式。所谓“偏向”，指的是这个锁会偏向于 Thread#1， 若接下来没有其他线程进入临界区，则 Thread#1 再出入 临界区无需再执行任何同步操作。也就是说，若只有 Thread#1 会进入临界区，实际上只有 Thread#1 初次进入 临界区时需要执行 CAS 操作，以后再出入临界区都不会有 同步操作带来的开销。
 
轻量级锁</br>
偏向锁的场景太过于理想化，更多的时候是 Thread#2 也 会尝试进入临界区， 如果 Thread#2 也进入临界区但是 Thread#1 还没有执行完同步代码块时，会暂停 Thread#1 并且升级到轻量级锁。Thread#2 通过自旋再次尝试以轻量 级锁的方式来获取锁

重量级锁</br>
如果 Thread#1 和 Thread#2 正常交替执行，那么轻量级锁 基本能够满足锁的需求。但是如果 Thread#1 和 Thread#2 同时进入临界区，那么轻量级锁就会膨胀为重量级锁，意味着Thread#1 线程获得了重量级锁的情况下，Thread#2 就会被阻塞


## java 内存模型

参考：http://www.luzhengxiang.com/2019/12/20/JVM%E5%9F%BA%E7%A1%802/

## GC G1 和CRM的区别

CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。

G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。

## 内存泄漏与内存溢出的区别
- 内存泄漏:对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。
- 内存溢出:内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。

## 什么情况下，java类会被回收
方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢?
判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满 足下面 3 个条件才能算是 “无用的类” :
1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然 被回收。

## 不可达的对象一定要被回收吗?
即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对 象死亡，至少要经历两次标记过程;可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此 对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机 将这两种情况视为没有必要执行。
被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关 联，否则就会被真的回收。

## major gc,full gc,Minor GC的区别
- major gc指的是老年代的gc。
- 而full gc等于young+old+metaspace的gc。
- Minor GC:新生代


## 强引用，软引用，弱引用，虚引用。
什么是强引用
Object obj = new Object()，这里的的obj就是强引用，通过关键字new创建的对象所关联的引用就是强引用。 只要有强引用指向一个对象，就能表明对象还活着，垃圾收集器就不会触碰这种对象，当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略

软引用
什么是软引用
是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。

软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象

有什么应用场景
软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

弱引用
什么是弱引用
并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化

弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存

有什么应用场景
弱应用同样可用于内存敏感的缓存

幻象引用(虚引用)
什么是幻象引用
虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收

## 一致性hash算法

## hashmap的实现原理




# 数据库

## mysql 索引的数据结构


# redis

## redis基础数据类型

## redis的持久化方式
### RDB（redis默认的持久化方式）
将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。
缺点：
不是实时写入的有可能造成数据的丢失。
## AOF
原理是将Reids的操作日志以追加的方式写入文件。

### redis集群


# nginx


# 场景解决

## 实现一个类似微信抢红包的功能
利用redis的list创建对应个数和金额随机的红包