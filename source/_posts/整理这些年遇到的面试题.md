---
title: 整理这些年遇到的面试题
date: 2020-08-04 10:09:40
tags: java面试题 java
---

# 
总是觉得自己记性特别不好，好多技术相关的东西都是记完了就忘，记录一下自己整理的一些高频面试题。方便随时翻阅加深记忆。

## java基础

### java线程的生命周期 
线程一共有 6 种状态

- NEW （初始状态，线程被构建，但是还没有调用 start 方法）
- RUNNABLE （运行状态，JAVA 线程把操作系统中的就绪 和运行两种状态统一称为“运行中”）
- BLOCKED
-- 阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况：
--- 等待阻塞:运行的线程执行 wait 方法，jvm 会把当前线程放入到等待队列
--- 同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm会把当前的线程放入到锁池中
--- 其他阻塞:运行的线程执行 Thread.sleep 或者 t.join 方法，或者发出了 I/O 请求时，JVM 会把当前线程设置为阻塞状态，当 sleep 结束、join 线程终止、io 处理完毕则线程恢复
- WAITING 等待
- TIME_WAITING （超时等待状态，超时以后自动返回）
- TERMINATED （终止状态，表示当前线程执行完毕）

如何关闭一个线程
Thread.interrupted

### 序列化的底层是怎么实现的。

假定一个User类，它的对象需要序列化，可以有如下三种方法：

（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化

ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。
ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。

（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。

ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。
ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。

（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。

ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。
ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。


注意事项：
- 序列化时，只对对象的状态进行保存，而不管对象的方法；
- 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
- 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
- 声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。
- 并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如：
    1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。
2. 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。

参考自：https://blog.csdn.net/xlgen157387/article/details/79840134


### synchronized的底层是怎么实现的。
synchronized简单的说就是java锁，通过代码层面的加锁，让代码在并发情况下按照我们定义的执行顺序来执行。
synchronized 有三种方式来加锁，分别是
1. 修饰实例方法，作用于当前实例加锁，进入同步代码前
要获得当前实例的锁
2. 静态方法，作用于当前类对象加锁，进入同步代码前要
获得当前类对象的锁
3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同
步代码库前要获得给定对象的锁。

synchronized在jdk1.6之后做过优化，引入了偏向锁，轻量级锁的概念，假设以下三种场景
- 情况一:只有 Thread#1 会进入临界区; 
- 情况二:Thread#1 和 Thread#2 交替进入临界区,竞争不激 烈;
- 情况三:Thread#1/Thread#2/Thread3... 同时进入临界区， 竞争激烈

偏向锁</br>
此时当 Thread#1 进入临界区时，JVM 会将 lockObject 的 对象头 Mark Word 的锁标志位设为“01”，同时会用 CAS 操作把 Thread#1 的线程 ID 记录到 Mark Word 中，此时进 入偏向模式。所谓“偏向”，指的是这个锁会偏向于 Thread#1， 若接下来没有其他线程进入临界区，则 Thread#1 再出入 临界区无需再执行任何同步操作。也就是说，若只有 Thread#1 会进入临界区，实际上只有 Thread#1 初次进入 临界区时需要执行 CAS 操作，以后再出入临界区都不会有 同步操作带来的开销。
 
轻量级锁</br>
偏向锁的场景太过于理想化，更多的时候是 Thread#2 也 会尝试进入临界区， 如果 Thread#2 也进入临界区但是 Thread#1 还没有执行完同步代码块时，会暂停 Thread#1 并且升级到轻量级锁。Thread#2 通过自旋再次尝试以轻量 级锁的方式来获取锁

重量级锁</br>
如果 Thread#1 和 Thread#2 正常交替执行，那么轻量级锁 基本能够满足锁的需求。但是如果 Thread#1 和 Thread#2 同时进入临界区，那么轻量级锁就会膨胀为重量级锁，意味着Thread#1 线程获得了重量级锁的情况下，Thread#2 就会被阻塞


### java 内存模型




参考：http://www.luzhengxiang.com/2019/12/20/JVM%E5%9F%BA%E7%A1%802/

### GC G1 和CRM的区别



## 数据库


## redis


## 场景解决

### 实现一个类似微信抢红包的功能
