<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2020%2F03%2F18%2Fredis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2020%2F03%2F18%2Fmysql%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java线程]]></title>
    <url>%2F2020%2F03%2F18%2Fjava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程和进程一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源分配的基本单位，线程是进程中执行运算的最小单位，亦是调度运行的基本单位。 线程基础如何创建一个线程在创建一个线程时，最好为这个线程设置线程名称，因为这样在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示1，直接继承Tread类，重写run()。2，实现Runnable结构，实现run()方法。3，实现Callable接口。通过FutureTask包装器来创建thread线程。4，ThreadPool。 线程的生命周期线程一共有 6 种状态(NEW、RUNNABLE、BLOCKED、 WAITING、TIME_WAITING、TERMINATED) NEW:初始状态，线程被构建，但是还没有调用 start 方法。 RUNNABLE:运行状态，JAVA 线程把操作系统中的就绪 和运行两种状态统一称为“运行中”。 BLOCKED:阻塞状态，表示线程进入等待状态,也就是线程 因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况。➢等待阻塞:运行的线程执行 wait 方法，jvm 会把当前 线程放入到等待队列。 ➢同步阻塞:运行的线程在获取对象的同步锁时，若该同 步锁被其他线程锁占用了，那么 jvm 会把当前的线程 放入到锁池中。➢其他阻塞:运行的线程执行 Thread.sleep 或者 t.join 方 法，或者发出了 I/O 请求时，JVM 会把当前线程设置 为阻塞状态，当 sleep 结束、join 线程终止、io 处理完 毕则线程恢复。 WAITING 都是等待状态，与TIME_WAITING的区别只是不会超时。 TIME_WAITING:超时等待状态，超时以后自动返回。 TERMINATED:终止状态，表示当前线程执行完毕。 线程的启动调用start()方法去启动一个线程，当run方法中的代码执行完毕以后，线程的生命周期也将终止，调用start方法的语义是当前线程告诉JVM，启动调用start方法的线程。线程启动的原理，在Thread方法中，底层实际上个是调用了start0()的一个方法，，这个方法是在这个方法native修饰的一个底层方法 线程的终止线程的终止，并不是简单的调用 stop 命令去。虽然api仍然可以调用，但是和其他的线程控制方法如 suspend、 resume 一样都是过期了的不建议使用，就拿stop来说，stop方法在结束一个线程时并不会保证线程的资源正常释放，因此会导致程序可能出现一些不确定的状态。要优雅的去中断一个线程，在线程中提供了一个 interrupt 方法。 interrupt 方法 当其他线程通过调用当前线程的 interrupt 方法，表示向当前线程打个招呼，告诉他可以中断线程的执行了，至于什 么时候中断，取决于当前线程自己。 线程通过检查自身是否被中断来进行相应，可以通过 isInterrupted()来判断是否被中断。 Thread.interrupted()线程中还提供了静态方法 Thread.interrupted()对设置中断标识的线程复位。 其他的线程复位除了通过 Thread.interrupted 方法对线程中断标识进行复 位以外，还有一种被动复位的场景，就是对抛出 InterruptedException 异 常 的 方 法 ，在 InterruptedException 抛出之前，JVM 会先把线程的中断 标识位清除，然后才会抛出 InterruptedException，这个时 候如果调用 isInterrupted方法，将会返回false。 为什么要复位Thread.interrupted()是属于当前线程的，是当前线程对外 界中断信号的一个响应，表示自己已经得到了中断信号， 但不会立刻中断自己，具体什么时候中断由自己决定，让 外界知道在自身中断前，他的中断状态仍然是 false，这就 是复位的原因。需要注意的是，InterruptedException 异常的抛出并不意味 着线程必须终止，而是提醒当前线程有中断的操作发生， 至于接下来怎么处理取决于线程本身，比如 直接捕获异常不做任何处理 将异常往外抛出 停止当前线程，并打印异常信息 线程安全 一个对象是否是线程安全的，取决于它是否会被多个线程 访问，以及程序中是如何去使用这个对象的。所以，如果 多个线程访问同一个共享对象，在不需额外的同步以及调 用端代码不用做其他协调的情况下，这个共享对象的状态 依然是正确的(正确性意味着这个对象的结果与我们预期 规定的结果保持一致)，那说明这个对象是线程安全的。 理解锁的基础知识基础知识之一：锁的类型锁从宏观上分类，分为悲观锁与乐观锁。 乐观锁乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 悲观锁悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。 基础知识之二：java线程阻塞的代价java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。 如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。 明确java线程切换的代价，是理解java中各种锁的优缺点的基础之一。 在介绍java锁之前，先说下什么是markword，markword是java对象数据结构中的一部分，要详细了解java对象的结构可以点击这里,这里只做markword的详细介绍，因为对象的markword和java各种类型的锁密切相关； markword数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，它的最后2bit是锁状态标志位，用来标记当前对象的状态，对象的所处的状态，决定了markword存储的内容，如下表所示: 32位虚拟机在不同状态下markword结构如下图所示： 基础知识之三：markwordsynchronized 的基本认识在多线程并发编程中 synchronized 一直是元老级角色，很 多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不 那么重，Java SE 1.6 中为了减少获得锁和释放锁带来的性 能消耗而引入的偏向锁和轻量级锁。 synchronized 的基本语法synchronized 有三种方式来加锁，分别是 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。不同的修饰类型，代表锁的控制粒度 锁是如何存储的 为什么任何对象都可以实现锁 首先，Java 中的每个对象都派生自 Object 类，而每个 Java Object 在 JVM 内部都有一个 native 的 C++对象 oop/oopDesc 进行对应。 线程在获取锁的时候，实际上就是获得一个监视器对象(monitor) ,monitor 可以认为是一个同步对象，所有的 Java 对象是天生携带 monitor。多个线程访问同步代码块时，相当于去争抢对象监视器 修改对象中的锁标识 synchronized锁的升级在分析 markword 时，提到了偏向锁、轻量级锁、重量级 锁。在分析这几种锁的区别时，我们先来思考一个问题 使用锁能够实现数据的安全性，但是会带来性能的下降。 不使用锁能够基于线程并行提升程序性能，但是却不能保 证线程安全性。这两者之间似乎是没有办法达到既能满足 性能也能满足安全性的要求。hotspot 虚拟机的作者经过调查发现，大部分情况下，加锁 的代码不仅仅不存在多线程竞争，而且总是由同一个线程 多次获得。所以基于这样一个概率，是的 synchronized 在 JDK1.6 之后做了一些优化，为了减少获得锁和释放锁带来 的性能开销，引入了偏向锁、轻量级锁的概念。因此大家 会发现在 synchronized 中，锁存在四种状态 分别是:无锁、偏向锁、轻量级锁、重量级锁; 锁的状态 根据竞争激烈的程度从低到高不断升级。 偏向锁偏向锁的基本原理 前面说过，大部分情况下，锁不仅仅不存在多线程竞争， 而是总是由同一个线程多次获得，为了让线程获取锁的代 价更低就引入了偏向锁的概念。怎么理解偏向锁呢? 当一个线程访问加了同步锁的代码块时，会在对象头中存 储当前线程的 ID，后续这个线程进入和退出这段加了同步 锁的代码块时，不需要再次加锁和释放锁。而是直接比较 对象头里面是否存储了指向当前线程的偏向锁。如果相等 表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了。 偏向锁的获取 首先获取锁 对象的 Markword，判断是否处于可偏向状 态。(biased_lock=1、且 ThreadId 为空) 如果是可偏向状态，则通过 CAS 操作，把当前线程的 ID 写入到 MarkWord a) 如果 cas 成功，那么 markword 就会变成这样。 表示已经获得了锁对象的偏向锁，接着执行同步代码块 b) 如果 cas 失败，说明有其他线程已经获得了偏向锁， 这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁(这个 操作需要等到全局安全点，也就是没有线程在执行字节码)才能执行 如果是已偏向状态，需要检查 markword 中存储的 ThreadID 是否等于当前线程 ThreadID a) 如果相等，不需要再次获得锁，可直接执行同步代码块. b) 如果不相等，说明当前锁偏向于其他线程，需要撤销 偏向锁并升级到轻量级锁. 偏向锁的撤销 偏向锁的撤销并不是把对象恢复到无锁可偏向状态(因为 偏向锁并不存在锁释放的概念)，而是在获取偏向锁的过程 中，发现 cas 失败也就是存在线程竞争时，直接把被偏向 的锁对象升级到被加了轻量级锁的状态。对原持有偏向锁的线程进行撤销时，原获得偏向锁的线程 有两种情况: 原获得偏向锁的线程如果已经退出了临界区，也就是同步代码块执行完了，那么这个时候会把对象头设置成无 锁状态并且争抢锁的线程可以基于 CAS 重新偏向当前线程。 如果原获得偏向锁的线程的同步代码块还没执行完，处于临界区之内，这个时候会把原获得偏向锁的线程升级为轻量级锁后继续执行同步代码块。 偏向锁流程图分析： 在我们的应用开发中，绝大部分情况下一定会存在2个以上的线程竞争，那么如果开启偏向锁，反而会提升获取锁的资源消耗。所以可以通过 jvm 参数 seBiasedLocking 来设置开启或关闭偏向锁 轻量锁锁升级为轻量级锁之后，对象的 Markword 也会进行相应 的的变化。升级为轻量级锁的过程: 线程在自己的栈桢中创建锁记录 LockRecord。 将锁对象的对象头中的 MarkWord 复制到线程的刚刚创建的锁记录中。 将锁记录中的 Owner 指针指向锁对象。 将锁对象的对象头的 MarkWord 替换为指向锁记录的指针。 自旋锁轻量级锁在加锁过程中，用到了自旋锁。所谓自旋，就是指当有另外一个线程来竞争锁时，这个线 程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。 注意，锁在原地循环的时候，是会消耗 cpu 的，就相当于在执行一个啥也没有的 for 循环。所以，轻量级锁适用于那些同步代码块执行的很快的场景， 这样，线程原地等待很短的时间就能够获得锁了。 自旋锁的使用，其实也是有一定的概率背景，在大部分同 步代码块执行的时间都是很短的。所以通过看似无意义的循环反而能提升锁的性能。 但是自旋必须要有一定的条件控制，否则如果一个线程执行同步代码块的时间很长，那么这个线程不断的循环反而会消耗 CPU 资源。默认情况下自旋的次数是 10 次， 可以通过 preBlockSpin 来修改。 在 JDK1.6 之后，引入了自适应自旋锁，自适应意味着自旋 的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过， 那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源 轻量级锁的解锁轻量级锁的锁释放逻辑其实就是获得锁的逆向逻辑，通过 CAS 操作把线程栈帧中的 LockRecord 替换回到锁对象的 MarkWord 中，如果成功表示没有竞争。如果失败，表示当前锁存在竞争，那么轻量级锁就会膨胀成为重量级锁 流程图如下图： 重量级锁的基本原理当轻量级锁膨胀到重量级锁之后，意味着线程只能被挂起 阻塞来等待被唤醒了。 重量级锁的 monitor加了同步代码块以后，在字节码中会看到一个 monitorenter 和 monitorexit。每一个 JAVA 对象都会与一个监视器 monitor 关联，我们 可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 修饰的同步方法或者代码块时，该线程得先 获取到 synchronized 修饰的对象对应的 monitor。monitorenter 表示去获得一个对象监视器。monitorexit 表 示释放 monitor 监视器的所有权，使得其他被阻塞的线程 可以尝试去获得这个监视器。monitor 依赖操作系统的 MutexLock(互斥锁)来实现的, 线程被阻塞后便进入内核(Linux)调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。 重量级锁的加锁的基本流程任意线程对 Object(Object 由 synchronized 保护)的访问，首先要获得 Object 的监视器。如果获取失败，线程进 入同步队列，线程状态变为 BLOCKED。当访问 Object 的前驱(获得了锁的线程)释放了锁，则该释放操作唤醒阻 塞在同步队列中的线程，使其重新尝试对监视器的获取。 重量级锁的流程： 整体梳理线程的竞争机制再来回顾一下线程的竞争机制对于锁升级这块的一些基本 流程。方便更好的理解 加入有这样一个同步代码块，存在 Thread#1、Thread#2 等多个线程 123synchronized (lock) &#123; // do something&#125; 情况一:只有 Thread#1 会进入临界区; 情况二:Thread#1 和 Thread#2 交替进入临界区,竞争不激烈; 情况三:Thread#1/Thread#2/Thread3… 同时进入临界区，竞争激烈 偏向锁 此时当 Thread#1 进入临界区时，JVM 会将 lockObject 的 对象头 Mark Word 的锁标志位设为“01”，同时会用 CAS 操作把 Thread#1 的线程 ID 记录到 Mark Word 中，此时进 入偏向模式。所谓“偏向”，指的是这个锁会偏向于 Thread#1， 若接下来没有其他线程进入临界区，则 Thread#1 再出入 临界区无需再执行任何同步操作。也就是说，若只有 Thread#1 会进入临界区，实际上只有 Thread#1 初次进入 临界区时需要执行 CAS 操作，以后再出入临界区都不会有 同步操作带来的开销。 轻量级锁 偏向锁的场景太过于理想化，更多的时候是 Thread#2 也 会尝试进入临界区， 如果 Thread#2 也进入临界区但是 Thread#1 还没有执行完同步代码块时，会暂停 Thread#1 并且升级到轻量级锁。Thread#2 通过自旋再次尝试以轻量 级锁的方式来获取锁 重量级锁 如果 Thread#1 和 Thread#2 正常交替执行，那么轻量级锁 基本能够满足锁的需求。但是如果 Thread#1 和 Thread#2 同时进入临界区，那么轻量级锁就会膨胀为重量级锁，意 味着 Thread#1 线程获得了重量级锁的情况下，Thread#2 就会被阻塞 Synchronized 结合 Java Object 对象中的 wait,notify,notifyAll被阻塞的线程什么时候被唤醒，取决于获得锁的线程什么时候执行完同步代码块并且释放锁。那怎么做到显示控制呢?我们就需要 借助一个信号机制: 在 Object 对象中，提供了 wait/notify/notifyall，可以用于控制线程的状态。 wait/notify/notifyall 基本概念 wait:表示持有对象锁的线程 A 准备释放对象锁权限，释放 cpu 资源并进入等待状态。 notify:表示持有对象锁的线程 A 准备释放对象锁权限，通 知 jvm 唤醒某个竞争该对象锁的线程 X。线程 A synchronized 代码执行结束并且释放了锁之后，线程 X 直 接获得对象锁权限，其他竞争线程继续等待(即使线程 X 同 步完毕，释放对象锁，其他竞争线程仍然等待，直至有新 的 notify ,notifyAll 被调用)。 notifyAll:notifyall 和 notify 的区别在于，notifyAll 会唤醒 所有竞争同一个对象锁的所有线程，当已经获得锁的线程 A 释放锁之后，所有被唤醒的线程都有可能获得对象锁权 限 需要注意的是:三个方法都必须在 synchronized 同步关键 字所限定的作用域中调用，否则会报错 java.lang.IllegalMonitorStateException ，意思是因为没有同步，所以线程对对象锁的状态是不确定的，不能调用这 些方法。 另外，通过同步机制来确保线程从 wait 方法返回时能够感知到感知到 notify 线程对变量做出的修改 wait/notify 的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243public class ThreadA extends Thread&#123; private Object lock; public ThreadA(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; synchronized (lock)&#123; System.out.println("start ThreadA"); try &#123; lock.wait(); //实现线程的阻塞 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("end ThreadA"); &#125; &#125;&#125;public class ThreadB extends Thread&#123; private Object lock=new Object(); public ThreadB(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; synchronized (lock)&#123; System.out.println("start ThreadB"); lock.notify(); //唤醒被阻塞的线程 System.out.println("end ThreadB"); &#125; &#125;&#125;public class WaitNotifyDemo &#123; public static void main(String[] args) &#123; Object lock=new Object(); ThreadA threadA=new ThreadA(lock); threadA.start(); ThreadB threadB=new ThreadB(lock); threadB.start(); &#125;&#125; wait/notify 的基本原理 Volatilevolatile 可以使得在多处理器环境下保证了共享变量的可见性。 在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程环境下，读和写发生在不同的线程中的时候，可能会出现:读线程不能及时的读取到其他线程写入的最新的值。这就是所谓的可见性为了实现跨线程写入的内存可见性，必须使用到一些机制 来实现。而 volatile 就是这样一种机制。 123456789101112131415public class VolatileDemo &#123; public /*volatile*/ static boolean stop = false; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; int i = 0; while (!stop)&#123; i++; &#125; &#125;); thread.start(); System.out.println("begin start thread"); Thread.sleep(1000); stop = true; &#125;&#125; Thread.join123456789101112131415161718192021222324public class JoinTest &#123; public static void main(String [] args) throws InterruptedException &#123; ThreadJoinTest t1 = new ThreadJoinTest("小明"); ThreadJoinTest t2 = new ThreadJoinTest("小东"); t1.start(); /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是： 程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕 所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会 */ t1.join(); t2.start(); &#125;&#125;class ThreadJoinTest extends Thread&#123; public ThreadJoinTest(String name)&#123; super(name); &#125; @Override public void run()&#123; for(int i=0;i&lt;1000;i++)&#123; System.out.println(this.getName() + ":" + i); &#125; &#125;&#125; JMM线程池线程问题如何排查常见的面试题如何保证多个线程串行执行thread.join 线程池的实现原理sleep和wait的区别Synchronized 和Lock的区别如何有效避免死锁ConcurrentHashMap的实现原理线程间如何通讯volatile 关键字在什么场景下使用。在高并发场景下，保证共享变量的可见性。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合]]></title>
    <url>%2F2020%2F03%2F15%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[java中集合大纲首先我们看结构类图 在java中，主要是collection和map两个集合接口，我们在java中使用到的所有集合都是继承或者实现了这两个接口。 CollectionCollection 接口中定义的方法12345678910111213141516171819202122232425262728293031323334353637int size(); //返回集合中元素个数boolean isEmpty(); //判断集合是否为空boolean contains(Object o); //判断集合中是否包含某元素Iterator&lt;E&gt; iterator(); //迭代器Object[] toArray(); //返回一个包含了本集合类中所有元素的数组。&lt;T&gt; T[] toArray(T[] a);boolean add(E e); //在集合末尾添加元素boolean remove(Object o); //若当前集合中有值与0的值相等的元素，则删除boolean containsAll(Collection&lt;?&gt; c);boolean addAll(Collection&lt;? extends E&gt; c);boolean removeAll(Collection&lt;?&gt; c);default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125; boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); @Override default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0); &#125; default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125; default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true); &#125; 常用Collection的实现类Collection 接口的接口 对象的集合（单列集合）├——-—-List 接口：元素按进入先后有序保存，可重复│—————- ├ LinkedList 接口实现类， 链表结构， 插入删除， 没有同步， 线程不安全│—————- ├ ArrayList 接口实现类， 数组结构， 随机访问， 没有同步， 线程不安全│—————- └ Vector 接口实现类 数组， 同步， 线程安全│ ———————-└ Stack 是Vector类的实现类└——-Set 接口： 仅接收一次，不可重复，并做内部排序├————└HashSet 使用hash表（数组）存储元素│————————└ LinkedHashSet 链表维护元素的插入次序└ —————-TreeSet 底层实现为二叉树，元素排好序 ListSetHashSetHashSet底层数据结构采用哈希表实现，元素无序且唯一，线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。具体实现唯一性的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。 LinkedHashSetLinkedHashSet底层数据结构采用链表和哈希表共同实现，链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性。线程不安全，效率高。 TreeSetTreeSet底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造），自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储；比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法； List和Set总结：（1）、List,Set都是继承自Collection接口.（2）、List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）（3）.Set和List对比：Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。（4）、ArrayList与LinkedList的区别和适用场景Arraylist：优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。LinkedList：优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景缺点：因为LinkedList要移动指针,所以查询操作性能比较低。适用场景分析：当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。 Vector Vector 线程安全 与arraylist的实现一样也是一个动态数组。但是因为他很多方法用了synchronized来修饰是线程同步的，效率很低，一般不建议使用 常见的面试题如何解决arraylist线程不安全的问题1，使用Vector2，使用Collections.synchronizedList。它会自动将我们的list方法进行改变，最后返回给我们一个加锁了List 1protected static List&lt;Object&gt; arrayListSafe2 = Collections.synchronizedList(new ArrayList&lt;Object&gt;()); 3,使用JUC中的CopyOnWriteArrayList类进行替换。 Map Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。 Map中定义的方法12345678910111213int size();boolean isEmpty();boolean containsKey(Object key);// 查询Map中是否包含指定的key，如果包含则返回trueboolean containsValue(Object value); // 查询Map中是否包含指定value，如果包含则返回trueV get(Object key); //获取对象V put(K key, V value); //设置对象V remove(Object key); //移除对象void putAll(Map&lt;? extends K, ? extends V&gt; m);void clear(); //清空集合Set&lt;K&gt; keySet(); //返回所有key组成的set集合Collection&lt;V&gt; values(); // 返回Map中所有的values Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); 返回set集合，里面是当前map集合中的entry... Map 常用的实现类Map 接口 键值对的集合 （双列集合）├———Hashtable 接口实现类， 同步， 线程安全├———HashMap 接口实现类 ，没有同步， 线程不安全-│—————–├ LinkedHashMap 双向链表和哈希表实现│—————–└ WeakHashMap├ ——–TreeMap 红黑树对所有的key进行排序└———IdentifyHashMap———————————————— HashMapjdk1.7 底层是数组+链表jdk1.8 底层是数组+链表+红黑树实现非线程安全 //todo 画出hashmap.put的流程图 HashTableStringBuilder是非线程安全的，StringBuffer是线程安全的。 部分内容参考自 ：https://blog.csdn.net/feiyanaffection/article/details/81394745]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM基础2]]></title>
    <url>%2F2019%2F12%2F20%2FJVM%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[1 Java虚拟机栈和栈帧 官网 :https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6 栈帧:每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。 每个栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向运行时常量池的引用(A reference to the run-time constant pool)、方法返回地址(Return Address)和附加信息。 局部变量表:方法中定义的局部变量以及方法的参数存放在这张表中 局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载至操作数栈中作为操作数使用。 操作数栈:以压栈和出栈的方式存储操作数的 动态链接:每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态 连接(Dynamic Linking)。 方法返回地址:当一个方法开始执行后,只有两种方式可以退出，一种是遇到方法返回的字节码指令;一种是遇见异常，并且 这个异常没有在方法体内得到处理。 2 堆栈之间的关系2.1栈指向堆如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的 对象。 2.2 方法区指向堆方法区中会存放静态变量，常量等数据。如果是下面这种情况，就是典型的方法区中元素指向堆中的对象。 1private static Object obj=new Object(); 2.3 堆指向方法区方法区中会包含类的信息，堆中会有对象，那怎么知道对象是哪个类创建的呢?]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM基础1]]></title>
    <url>%2F2019%2F12%2F19%2FJVM%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[1 java jdk 1.81.1 The relation of JDK/JRE/JVMjdk、jre、jvm的关系可以用下图表示 2源码到类文件2.1源码123456789101112class Person&#123; private String name; private int age; private static String address; private final static String hobby=&quot;Programming&quot;; public void say()&#123; System.out.println(&quot;person say...&quot;); &#125; public int calc(int op1,int op2)&#123; return op1+op2; &#125;&#125; 编译: javac Person.java —&gt; Person.class 2.2编译过程Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件 2.3类文件(Class文件)官网The class File Format :https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html 123cafe babe 0000 0034 0027 0a00 0600 1809 0019 001a 0800 1b0a 001c 001d 0700 1e07 001f 0100 046e 616d 6501 0012 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 0100 0361 6765 0100 0149 0100 0761 6464 7265 ...... magic(魔数):The magic item supplies the magic number identifying the class file format; it has thevalue 0xCAFEBABE . 3类文件到虚拟机(类加载机制)3.1装载(Load)查找和导入class文件 1.通过一个类的全限定名获取定义此类的二进制字节流 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3.在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 3.2链接(Link)3.2.1验证(Verify) 保证被加载类的正确性 文件格式验证 元数据验证 字节码验证 符号引用验证 3.2.2准备（Prepare） 为类的静态变量分配内存，并将其初始化为默认值 3.2.3解析（Resolve） 把类中的符号引用转换为直接引用 3.3初始化（Initialize） 对类的静态变量，静态代码块执行初始化操作 3.4类加载机制图解 使用和卸载不算是类加载过程中的阶段，这里只是为了完整性 4类装载器ClassLoader 在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载器完成，顾名思义，就是用来装载Class文件的。(1)通过一个类的全限定名获取定义此类的二进制字节流 4.1分类12341)Bootstrap ClassLoader 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或 Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。2)Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中 jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。3)App ClassLoader 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和 jar包。4)Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据 自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader。 4.2图解 4.3加载原则检查某个类是否已经加载:顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个Classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。 加载的顺序:加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 双亲委派机制 定义:如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就 成功返回;只有父类加载器无法完成此加载任务时，才自己去加载。优势:Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的 Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型 最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用 双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object 类。破坏:可以继承ClassLoader类，然后重写其中的loadClass方法，其他方式大家可以自己了解 拓展一下。 5运行时数据区(Run-Time Data Areas) 在装载阶段的第(2),(3)步可以发现有运行时数据，堆，方法区等名词(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 (3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口 说白了就是类文件被类装载器装载进来之后，类中的内容(比如变量，常量，方法，对象等这些数 据得要有个去处，也就是要存储起来，存储的位置肯定是在JVM中有对应的空间) 5.1官网概括https://docs.oracle.com/javase/specs/jvms/se8/html/index.html 摘要 1The Java Virtual Machine defines various run-time data areas that are used during execution of a program. Some of these data areas are created on Java Virtual Machine start-up and are destroyed only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread data areas are created when a thread is created and destroyed when the thread exits. 5.2图解 5.3常规理解5.3.1Method Area(方法区)方法区是各个线程共享的内存区域，在虚拟机启动时创建。 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目 的是与Java堆区分开来。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 1234The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads.The method area is created on virtual machine start-up.Although the method area is logically part of the heap,......If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError. 此时回看装载阶段的第2步:(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据 结构 如果这时候把从Class文件到装载的第(1)和(2)步合并起来理解的话，可以画个图 值得说明的 (1)方法区在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space (2)Run-Time Constant PoolClass文件中除了有类的版本、字段、方法、接口等描述 信息外，还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在 类加载后进入方法区的运行时常量池中存放。 1Each run-time constant pool is allocated from the Java Virtual Machine&apos;s method area (§2.5.4).s 5.3.2Heap(堆)Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。Java对象实例以及数组都在堆上分配。 12The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated.The heap is created on virtual machine start-up. 此时回看装载阶段的第3步:(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方 法区中这些数据的访问入口 此时装载(1)(2)(3)的图可以改动一下 5.3.3Java Virtual Machine Stacks(虚拟机栈) 经过上面的分析，类加载机制的装载过程已经完成，后续的链接，初始化也会相应的生效。假如目前的阶段是初始化完成了，后续做啥呢?肯定是Use使用咯，不用的话这样折腾来折腾去 有什么意义?那怎样才能被使用到?换句话说里面内容怎样才能被执行?比如通过主函数main调 用其他方法，这种方式实际上是main线程执行之后调用的方法，即要想使用里面的各种内容，得 要以线程为单位，执行相应的方法才行。那一个线程执行的状态如何维护?一个线程可以执行多少个方法?这样的关系怎么维护呢? 虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行 状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。 调用一个方法，就会向栈中压入一个栈帧;一个方法调用完成，就会把该栈帧从栈中弹出。 1Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread. A Java Virtual Machine stack stores frames (§2.6). 画图理解栈和栈帧 5.3.4The pc Register(程序计数器) 我们都知道一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据 CPU调度来的。假如线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获 得CPU执行权的时候，怎么能继续执行呢?这就是需要在线程中维护一个变量，记录线程执行到 的位置。 程序计数器占用的内存空间很小，由于Java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时 间的方式来实现的，在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够 恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是Native方法，则这个计数器为空。 12The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine&apos;s pc register is undefined. The Java Virtual Machine&apos;s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform. 5.3.5Native Method Stacks(本地方法栈)如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 基础梳理]]></title>
    <url>%2F2019%2F06%2F17%2Fpython-%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习selenium笔记]]></title>
    <url>%2F2019%2F06%2F13%2Fpython%E4%BD%BF%E7%94%A8selenium%E5%81%9A%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[前言Selenium是一个浏览器自动化操作框架。可以模拟用户操作。这样我们就可以用selenium做很多事情了，测试自动化，爬虫。这里我接触和学习selenium也是使用来作为爬虫。 安装1pip install selenium 同时还需要在你的电脑上安装浏览器驱动。安装你本机浏览器对应版本的浏览器驱动。Chromedriver: http://npm.taobao.org/mirrors/chromedriver/ 具体操作控制浏览器操作的一些方法123456789101112set_window_size() 设置浏览器的大小back() 控制浏览器后退forward() 控制浏览器前进refresh() 刷新当前页面clear() 清除文本send_keys (value) 模拟按键输入click() 单击元素submit() 用于提交表单get_attribute(name) 获取元素属性值is_displayed() 设置该元素是否用户可见size 返回元素的尺寸text 获取元素的文本 鼠标事件12345678ActionChains(driver) 构造ActionChains对象context_click() 执行鼠标悬停操作move_to_element(above) 右击double_click() 双击drag_and_drop() 拖动move_to_element(above) 执行鼠标悬停操作context_click() 用于模拟鼠标右键操作， 在调用时需要指定元素定位perform() 执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作 键盘事件123456789101112常用键盘操作send_keys(Keys.BACK_SPACE) 删除键（BackSpace）send_keys(Keys.SPACE) 空格键(Space)send_keys(Keys.TAB) 制表键(Tab)send_keys(Keys.ESCAPE) 回退键（Esc）send_keys(Keys.ENTER) 回车键（Enter）组合键盘操作send_keys(Keys.CONTROL,‘a’) 全选（Ctrl+A）send_keys(Keys.CONTROL,‘c’) 复制（Ctrl+C）send_keys(Keys.CONTROL,‘x’) 剪切（Ctrl+X）send_keys(Keys.CONTROL,‘v’) 粘贴（Ctrl+V）send_keys(Keys.F1…Fn) 键盘 F1…Fn 定位一组元素 定位一个元素 定位多个元素 含义 find_element_by_id find_elements_by_id 通过元素id定位 find_element_by_name find_elements_by_name 通过元素name定位 find_element_by_xpath find_elements_by_xpath 通过xpath表达式定位 find_element_by_link_text find_elements_by_link_tex 通过完整超链接定位 find_element_by_partial_link_text find_elements_by_partial_link_text 通过部分链接定位 find_element_by_tag_name find_elements_by_tag_name 通过标签定位 find_element_by_class_name find_elements_by_class_name 通过类名进行定位 find_elements_by_css_selector find_elements_by_css_selector 通过css选择器进行定位 示例代码页面html截图 12345678910111213141516171819202122from selenium import webdriverimport timebrowser = webdriver.Firefox()browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')time.sleep(5)liuyan_list = browser.find_elements_by_xpath('//*[@id="j-comment-section"]/div/div[3]/div/ul[3]/li')#获取用户留言liuyan_content = liuyan_list[0].find_element_by_class_name('shiyongxinde.oh')print(liuyan_content.text)liuyan_shijian = liuyan_list[0].find_element_by_class_name('info-time').find_element_by_tag_name('a').text#获取留言时间print(liuyan_shijian)liuyan_id = liuyan_list[0].find_element_by_class_name('woZanTong').get_attribute('appraiseid')#获取留言idprint(liuyan_id)nick_name = liuyan_list[0].find_element_by_class_name('reply_avatar_userName').text#获取昵称print(nick_name) 多窗口切换在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。 1234current_window_handle 获得当前窗口句柄window_handles 返回所有窗口的句柄到当前会话switch_to.window() 用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。 调用JavaScript代码虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。 12直接翻到当前页面的页尾browser.execute_script('window.scrollTo(0, document.body.scrollHeight)') cookie操作12345get_cookies() 获得所有cookie信息get_cookie(name) 返回字典的key为“name”的cookie信息add_cookie(cookie_dict) 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值delete_cookie(name,optionsString) 删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”delete_all_cookies() 删除所有cookie信息 关闭浏览器123close() 关闭单个窗口quit() 关闭所有窗口 可能遇到的坑页面加载慢因为sulenium是代码控制浏览器操作，代码执行很快，浏览器执行很慢，经常发生代码执行到这里，但是页面资源没有加载完的情况。所以需要 time.sleep(5) 让程序等待几秒钟。 莫名其妙的异常我代码写的很开心，执行一下突然报错。。。就是那种明明上一次启动还正常，可能写了一行注释回来执行就报错了。。。让我不知所措，最后是restart大法好。重启就好了，我没有找到发生的具体原因，目前是出现就重启。。。 123456789/Users/luzhengxiang/anaconda3/envs/my_spider/bin/python /Users/luzhengxiang/PycharmProjects/autoSign/spiders/selenium_test/gome/guomei_selenium.pyTraceback (most recent call last): File "/Users/luzhengxiang/PycharmProjects/autoSign/spiders/selenium_test/gome/guomei_selenium.py", line 10, in &lt;module&gt; browser = webdriver.Chrome(); File "/Users/luzhengxiang/anaconda3/envs/my_spider/lib/python3.7/site-packages/selenium/webdriver/chrome/webdriver.py", line 73, in __init__ self.service.start() File "/Users/luzhengxiang/anaconda3/envs/my_spider/lib/python3.7/site-packages/selenium/webdriver/common/service.py", line 104, in start raise WebDriverException("Can not connect to the Service %s" % self.path)selenium.common.exceptions.WebDriverException: Message: Can not connect to the Service chromedriver 不同浏览器内核可能支持的方法不同我最开始基于firefox写的代码，后面直接替换成了chrome。很多原本正常的方法就报错了。猜测原因就是可能不同浏览器对这个selenium的支持不一样导致的。 参考链接：https://blog.csdn.net/weixin_36279318/article/details/79475388]]></content>
      <tags>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 常用命令]]></title>
    <url>%2F2019%2F06%2F12%2Flinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[工作中常用的命令记录查询12345678910111213141516171819202122lsof -i:端口号 查看端口被什么进程占用netstat -tunlp 查看端口使用情况。ps -ef|grep xxx 查询xxx的进程使用情况文件中根据关键字搜索Cat filename | grep XXX |grep XXX例如：cat zhang8online3.0.log |grep 50641658625520文件中根据关键字统计行数场景：查询接口调用次数cat localhost_access_log.2018-06-06.txt |grep getverifycode |wc -l例如：cat localhost_access_log.2018-06-07.txt |grep getverifycode |wc -l查询中使用正则匹配场景：查询耗时长的接口。cat zhang8online3.0.log | grep -E "耗时：[0-9]&#123;4,&#125;"df -h 查询 磁盘使用情况 操作命令12345678910111213往文件中写值，覆盖文件内容。在不删除文件的情况下清空文件内容echo "" &gt; ZH8.online.trade.logchmod 777 文件名 文件给权限解压tar包tar -xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar -xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip 定时任务1234crontab -helpcrontab -l 查看系统定时任务]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[热烈庆祝拖延症晚期的陆大大终于搭建了自己的个人博客啦看到很多人都有自己的博客，记录生活中的点点滴滴，记录自己的喜怒哀乐，记录学习的新技术，记录工作中踩的坑。弄一个自己的博客玩玩的想法在我心里其实很久了，但是直到今天，都2019年了，我才真的肯花点心思来弄，我的这个拖延症呀，我是真的都佩服我自己。不过有句话怎么说的呢，觉得为时已晚的时候，恰恰是是最早的时候。。。。 自我介绍一下我是90狮子座的沪漂程序猿，喜欢唱，跳，篮球……不对不对不对，跑偏了，哈哈哈。我的主要技术方向是java，但是现在公司业务需要整合了几条业务线，我负责的项目都交接给了别的同事，现在的我挺迷茫的，公司的安排是我们组作为后背力量，准备应对可能出现的其它项目，然后整理公司的数据。参与数据的开发，（个人感觉我真的是在在失业的边缘徘徊。。。）所以我现在是什么都会去涉及一点，nodejs，python，elk，因为接触时间补偿，目前都涉入不深。 2012-9月份 - 2019年6月我还记得我是2012年的9月份来的上海，到现在已经7年了，我的妈呀，时间是真的可怕。我一点也不想承认我已经26岁，已经在脱发和被家人逼婚的路上越走越走越远。每天上班下班的日子其实说不上辛苦，但是真的觉得少了很多激情，我也已经不像以前刚工作那会，有干劲到可以连续上班一个月，天天11，2点下班还乐此不疲，觉得这就是奋斗，这是年轻人应该过的生活。人总是想着自己没有的，然后容易忽略掉自己拥有的东西，很显然我就是这一类人的代表了。总是很容易患得患失。其实都是给作的。 最后当然是总结陈词啦虽然自己挺多不好，但是还是不影响我是一个很阳光的宝藏男孩啦。以后我就要多写文章和技术博客来记录我的学习历程，和知识难点。好记性不如烂博客。然后就是多写文章来记录生活重的点点滴滴啦。]]></content>
      <tags>
        <tag>心情杂记</tag>
      </tags>
  </entry>
</search>
